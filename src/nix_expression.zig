const std = @import("std");

const Io = std.Io;

const BuildZigZon = @import("./BuildZigZon.zig");

/// Write Nix Expression
///
/// Writes the entire generated nix expression to the writer provided.
///
/// You may calculate the size of the buffer required
/// for the allocation with `calculateLength`.
pub fn write(
    writer: *Io.Writer,
    dependencies: []const BuildZigZon.Dependency,
) !void {
    try writeHeader(writer);

    for (dependencies) |dependency|
        try writeDependency(writer, dependency);

    try writeFooter(writer);
}

/// Calculate Nix Expression Length
///
/// Predict the exact length (in bytes) needed to allocate
/// the full nix expression based on the list of
/// dependencies.
pub fn calculateLength(dependencies: []const BuildZigZon.Dependency) usize {
    var sum = header_text.len + footer_text.len;

    for (dependencies) |dependency| {
        const unqiue_text_len = dependency.name.len +
            dependency.url.len +
            dependency.hash.len -
            dependency_text_formatting_chars_count;

        sum += dependency_text.len + unqiue_text_len;
    }

    return sum;
}

/// Header Text
///
/// Text to print at the top of the nix expression.
pub const header_text =
    \\# generated by build.zig.nix (https://github.com/baileyluTCD/build.zig.nix)
    \\# consume with `pkgs.callPackage` and link to `$ZIG_GLOBAL_CACHE_DIR/p` 
    \\# before running `zig build ...`
    \\
    \\{ linkFarm, fetchurl }:
    \\
    \\linkFarm "zig-packages" [
;

/// Write Header
///
/// Prints `header_text` to the writer.
pub inline fn writeHeader(writer: *Io.Writer) !void {
    try writer.writeAll(header_text);
}

/// Dependency Text
///
/// Text to print for each dependency of the nix expression.
///
/// Contains formatting literals as is expected to be used with `print`.
pub const dependency_text =
    \\  {{
    \\    name = "{s}";
    \\    path = fetchurl {{
    \\      url = "{s}";
    \\      hash = "{s}";
    \\    }};
    \\  }}
    \\
;

const dependency_text_formatting_chars_count = 4 + 9;

/// Write Dependency
///
/// Prints a formatted version of `dependency_text` to the writer.
pub inline fn writeDependency(
    writer: *Io.Writer,
    dependency: BuildZigZon.Dependency,
) !void {
    try writer.print(dependency_text, .{
        dependency.name,
        dependency.url,
        dependency.hash,
    });
}

/// Footer Text
///
/// Text to print at the bottom of the nix expression.
pub const footer_text = "]";

/// Write Footer
///
/// Prints `footer_text` to the writer.
pub inline fn writeFooter(writer: *Io.Writer) !void {
    try writer.writeAll(footer_text);
}

const testing = std.testing;

const test_dependencies = [_]BuildZigZon.Dependency{
    BuildZigZon.Dependency{
        .name = "dep-one",
        .url = "git+https://github.com/dep/one",
        .hash = "sha256-4yRqfY8r2Ar9Fr45ikD/8jK+H3g4veEHfXa9BorLxXg=",
    },
    BuildZigZon.Dependency{
        .name = "dep-two",
        .url = "https://dep-two.com/tarball",
        .hash = "sha256-wq7bZ1/IlmmLkSa3GUJgK17dTWcKyf5A+ndS9yRwB88=",
    },
};

const test_write_output =
    header_text ++
    \\  {
    \\    name = "dep-one";
    \\    path = fetchurl {
    \\      url = "git+https://github.com/dep/one";
    \\      hash = "sha256-4yRqfY8r2Ar9Fr45ikD/8jK+H3g4veEHfXa9BorLxXg=";
    \\    };
    \\  }
    \\  {
    \\    name = "dep-two";
    \\    path = fetchurl {
    \\      url = "https://dep-two.com/tarball";
    \\      hash = "sha256-wq7bZ1/IlmmLkSa3GUJgK17dTWcKyf5A+ndS9yRwB88=";
    \\    };
    \\  }
    \\
    ++ footer_text;

test "nix expression is formed correctly and has correct length" {
    const bufLen = calculateLength(&test_dependencies);
    const buffer = try testing.allocator.alloc(u8, bufLen);
    defer testing.allocator.free(buffer);

    var writer = Io.Writer.fixed(buffer);
    try write(&writer, &test_dependencies);

    try testing.expectEqual(writer.end, buffer.len);
    try testing.expectEqualStrings(test_write_output, buffer);
}
